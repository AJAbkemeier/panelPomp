% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pfilter.R, R/pfilter_methods.R
\docType{class}
\name{pfilter}
\alias{pfilter}
\alias{pfilterd.ppomp-class}
\alias{pfilter,panelPomp-method}
\alias{logLik,pfilterd.ppomp-method}
\alias{unitlogLik,pfilterd.ppomp-method}
\title{Particle filtering for panel data}
\usage{
\S4method{pfilter}{panelPomp}(object, shared, specific, params, Np,
  tol = 1e-17, verbose = getOption("verbose"), ...)

\S4method{logLik}{pfilterd.ppomp}(object, ...)

\S4method{unitlogLik}{pfilterd.ppomp}(object, ...)
}
\arguments{
\item{object}{An object of class \code{panelPomp} or inheriting class 
\code{panelPomp}.}

\item{shared}{optional; the role of and requirements on 
these arguments depend on the type of object provided in the \code{object} 
argument.

If \code{object} is a \code{list} of \code{pomp}s, \code{shared} must be a 
numeric vector specifying parameter values shared among panel units; 
\code{specific} must be a \code{matrix} with parameter values that are 
unit-specific with rows naming parameters and columns naming units (these 
names must match those of \code{object}); \code{params} allows to specify 
both \code{shared} and \code{specific} as a single argument: a list with 
elements named 'shared' and 'specific.' If no values are specified and the 
\code{list} of \code{pomp}s has parameter values, the latter are set to be 
unit-specific.

If \code{object} is a \code{panelPomp} object, these arguments can still be 
used as described above. In addition, a character \code{shared} argument 
sets these parameter as shared (values for parameters that were not 
originally shared are taken from the specific parameters of the first panel 
unit). \code{shared=NULL} sets all parameters as unit-specific.}

\item{specific}{optional; the role of and requirements on 
these arguments depend on the type of object provided in the \code{object} 
argument.

If \code{object} is a \code{list} of \code{pomp}s, \code{shared} must be a 
numeric vector specifying parameter values shared among panel units; 
\code{specific} must be a \code{matrix} with parameter values that are 
unit-specific with rows naming parameters and columns naming units (these 
names must match those of \code{object}); \code{params} allows to specify 
both \code{shared} and \code{specific} as a single argument: a list with 
elements named 'shared' and 'specific.' If no values are specified and the 
\code{list} of \code{pomp}s has parameter values, the latter are set to be 
unit-specific.

If \code{object} is a \code{panelPomp} object, these arguments can still be 
used as described above. In addition, a character \code{shared} argument 
sets these parameter as shared (values for parameters that were not 
originally shared are taken from the specific parameters of the first panel 
unit). \code{shared=NULL} sets all parameters as unit-specific.}

\item{params}{optional; the role of and requirements on 
these arguments depend on the type of object provided in the \code{object} 
argument.

If \code{object} is a \code{list} of \code{pomp}s, \code{shared} must be a 
numeric vector specifying parameter values shared among panel units; 
\code{specific} must be a \code{matrix} with parameter values that are 
unit-specific with rows naming parameters and columns naming units (these 
names must match those of \code{object}); \code{params} allows to specify 
both \code{shared} and \code{specific} as a single argument: a list with 
elements named 'shared' and 'specific.' If no values are specified and the 
\code{list} of \code{pomp}s has parameter values, the latter are set to be 
unit-specific.

If \code{object} is a \code{panelPomp} object, these arguments can still be 
used as described above. In addition, a character \code{shared} argument 
sets these parameter as shared (values for parameters that were not 
originally shared are taken from the specific parameters of the first panel 
unit). \code{shared=NULL} sets all parameters as unit-specific.}

\item{Np}{
    the number of particles to use in filtering.
    This may be specified as a single positive integer, in which case the same number of particles will be used at each timestep.
    Alternatively, if one wishes the number of particles to vary across timestep, one may specify \code{Np} either as a vector of positive integers (of length \code{length(time(object))}) or as a function taking a positive integer argument.
    In the latter case, \code{Np(n)} must be a single positive integer, representing the number of particles to be used at the \code{n}-th timestep:
    \code{Np(1)} is the number of particles to use going from \code{timezero(object)} to \code{time(object)[1]},
    \code{Np(2)}, from \code{time(object)[1]} to \code{time(object)[2]},
    and so on.
    \strong{Note that this behavior differs from that of \code{\link{mif}}!}
  }

\item{tol}{filtering tolerance for all units.}

\item{verbose}{
    logical; if TRUE, print progress reports.
  }

\item{...}{additional arguments, passed to the \code{pfilter} method of \pkg{pomp}.}
}
\description{
Tools for applying particle filtering algorithms to panel data.
}
\section{Methods}{

\describe{
  \item{logLik}{Extracts the estimated log likelihood for the entire panel.}
  \item{unitlogLik}{Extracts the estimated log likelihood for each panel unit.}
  }
}

\references{
\arulampalam2002

\breto2017
}
\seealso{
\pkg{pomp}'s pfilter at \link[=pfilter,pomp-method]{pfilter}, \link{panel_loglik}

Other panelPomp workhorse functions: \code{\link{mif2}},
  \code{\link{panelPomp}}, \code{\link{panel_loglik}}
}
