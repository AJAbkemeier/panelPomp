\documentclass[12pt]{article}
\usepackage{amsmath}
\usepackage{graphicx}
%\usepackage{enumerate}
\usepackage{url} % not crucial - just used below for the URL
\usepackage{amsfonts}
\usepackage{setspace}
\usepackage{caption}
\usepackage{subcaption}
\usepackage[ruled,noline]{algorithm2e}
\usepackage[table]{xcolor}
\usepackage{mathtools}
\usepackage{authblk}
\usepackage{xspace}
\usepackage{natbib}
\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}
\DeclareMathOperator*{\argmax}{arg\,max}

%\pdfminorversion=4
% NOTE: To produce blinded version, replace "0" with "1" below.
\newcommand{\blind}{0}

\newcommand{\proglang}[1]{\textsf{#1}}
\newcommand\figTitle{\bf}
\newcommand\pkg{\texttt}
\newcommand\code{\texttt}
\newcommand\eic[1]{\textcolor{orange}{[EI: #1]}}
\newcommand\jwc[1]{\textcolor{brown}{[JW: #1]}}
\newcommand\TODO[1]{\textcolor{red}{[TODO: #1]}}
\newcommand\allVar{\psi}
\newcommand\allVarExt{\bar{\psi}}
\newcommand\improvedCell{\cellcolor{blue!25}}
\newcommand\R{\texttt{R}\xspace}
\newcommand\panelPomp{\texttt{panelPomp}\xspace}
\newcommand\pomp{\texttt{pomp}\xspace}
\newcommand\nimble{\texttt{nimble}\xspace}
\newcommand\mcstate{\texttt{mcstate}\xspace}
\newcommand\spatPomp{\texttt{spatPomp}\xspace}
\newcommand\PanelPOMP{PanelPOMP}
\newcommand\example[1]{ \item #1}

% PSUEDO-CODE HELPERS
\newcommand\mycolon{{\hspace{0.6mm}:\hspace{0.6mm}}}
\newcommand\np{j}
\newcommand\Np{J}   % Number of particles
\newcommand\nrep{i} % Replicate index (in likelihood evaluations)
\newcommand\Nrep{I} % Number of replicates (in likelihood evaluations)
\newcommand\unit{u} % Unit index
\newcommand\Unit{U} % Number of panel units
\renewcommand\time{n}
\newcommand\Time{N}
\newcommand\Nmif{M} % Number of iterated filtering steps
\newcommand\nmif{m} % Mif index
\newcommand\Shared{\Phi}
\newcommand\Specific{\Psi}
\newcommand\shared{\phi}
\newcommand\specific{\psi}
\newcommand\Nshared{A}
\newcommand\nshared{a}
\newcommand\Nspecific{B}
\newcommand\nspecific{b}
\newcommand\dimSpecific{{\mathrm{dim}(\Psi)}}
\newcommand\dimShared{{\mathrm{dim}(\Phi)}}
\newcommand\argequals{{\,=\,}}
\newcommand\mystretch{\rule[-2mm]{0mm}{5mm} }
\newcommand\myBigStretch{\rule[-3mm]{0mm}{5mm} }
\newcommand\asp{\hspace{6mm}}

% MATH HELPERS
\newcommand\RealSpace{\mathbb{R}}
\newcommand\loglik{\lambda}
\newcommand\lik{\ell}
\newcommand\Xspace{{\mathbb X}}
\newcommand\Yspace{{\mathbb Y}}
\newcommand\Rspace{{\mathbb R}}
\newcommand\hatTheta{\widehat{\Theta}}
\newcommand\Xdim{{\mathrm{dim}}(\Xspace)}
\newcommand\Ydim{{\mathrm{dim}}(\Yspace)}
%\newcommand\Thetadim{{{\mathrm{dim}}(\Theta)}}
\newcommand\Thetadim{D}
\newcommand\contactsRate{\Lambda}
\newcommand\given{{\, | \,}}
\newcommand\giventh{{\,;\,}}
\newcommand\normal{\mathrm{Normal}}
\newcommand\seq[2]{{#1}\!:\!{#2}}
\newcommand\prob{\mathbb{P}}

% MARGINS
\addtolength{\oddsidemargin}{-.5in}%
\addtolength{\evensidemargin}{-1in}%
\addtolength{\textwidth}{1in}%
\addtolength{\textheight}{1.7in}%
\addtolength{\topmargin}{-1in}%

\begin{document}

%\bibliographystyle{natbib}

\def\spacingset#1{\renewcommand{\baselinestretch}%
{#1}\small\normalsize} \spacingset{1}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \if0\blind
% {
%   \title{\bf Likelihood Based Inference for ARMA Models}
%   \author{
%     Carles Bret\'o, Universitat de Val\`encia\\
%     Jesse Wheeler, University of Michigan\\
%     Edward L. Ionides, University of Michigan\\
%     Aaron A. King, University of Michigan}
%   \maketitle
% } \fi

\if0\blind
{
  \title{\bf A tutorial on panel data analysis using partially observed Markov processes via the \R package \panelPomp}

  \author[1]{Carles Bret\'o}
  \author[2]{Jesse Wheeler}
  \author[2]{Aaron A. King}
  \author[2]{Edward L. Ionides}

  \affil[1]{Universitat de Val\`encia}
  \affil[2]{University of Michigan}

  \maketitle
} \fi

\if1\blind
{
  \bigskip
  \bigskip
  \bigskip
  \begin{center}
    {\Large\bf A tutorial on panel data analysis using partially observed Markov processes via the \R package \panelPomp}
\end{center}
  \medskip
} \fi

\bigskip
\begin{abstract}
\noindent The \R package \panelPomp supports analysis of panel data via a general class of partially observed Markov process models (PanelPOMP).
This package tutorial describes how the mathematical concept of a PanelPOMP is represented in the software and demonstrates typical use-cases of \panelPomp.
Monte Carlo methods used for POMP models require adaptation for PanelPOMP models due to the higher dimensionality of panel data.
The package takes advantage of recent advances for PanelPOMP, including an iterated filtering algorithm, Monte Carlo adjusted profile methodology and block optimization methodology to assist with the large parameter spaces that can arise with panel models.
In addition, tools for manipulation of models and data are provided that take advantage of the panel structure.
\end{abstract}

\vfill

<<Setup, include=FALSE,echo=FALSE,results='hide'>>=

run_level <- 3
VERBOSE <- FALSE

rda_dir <- paste0("rda",run_level,"/")
if(!dir.exists(rda_dir)) dir.create(rda_dir)

library(knitr)
library(panelPomp)
library(ggplot2)
library(foreach)
library(doParallel)
library(doRNG)

cores <- detectCores()/2
registerDoParallel(cores)
registerDoRNG(25880)

knitr::opts_chunk$set(
  echo = FALSE,
  warning = FALSE,
  message = FALSE,
  fig.align = 'center',
  dev = 'cairo_pdf'
)

# Setting black and white ggplot2 theme for entire document.
theme_set(
  theme_bw() +
    theme(
      plot.title = element_text(hjust = 0.5),
      text = element_text(family = 'Times')  # Try other options, including Helvetica, which is the default.
    )
)

myRound <- function (x, digits = 1)
{
    # taken from the broman package
    if (digits < 1)
        stop("This is intended for the case digits >= 1.")
    if (length(digits) > 1) {
        digits <- digits[1]
        warning("Using only digits[1]")
    }
    tmp <- sprintf(paste("%.", digits, "f", sep = ""), x)
    zero <- paste0("0.", paste(rep("0", digits), collapse = ""))
    tmp[tmp == paste0("-", zero)] <- zero
    tmp
}
@


\newpage
\spacingset{1.25}

\AtBeginEnvironment{algorithm}{%
  \singlespacing
  % \renewcommand{\arraystretch}{1}%
}

\section{Introduction}
\label{sec:intro}

This tutorial describes a typical use-case of the \panelPomp \R package.
Partially observed Markov process (POMP) models---also known as state-space or hidden Markov models---are useful mathematical tools for modeling non-linear dynamic systems.
POMP models describe a system via an unobserved dynamic model that has the Markov property, coupled with a model for how observations are drawn from the latent process.
Various software packages provide platforms for performing statistical analysis of these systems using POMP models (for instance, \pomp \citep{king16}, \spatPomp \citep{asfaw21}, \nimble \citep{michaud21}, and \mcstate \citep{fitzjohn20}).
However, particular challenges arise when modeling \emph{panel data} via POMP models; these data arise when time series are measured on a collection of independent units.
While each unit may be modeled separately, analyzing the data as a single collection can provide insights into the underlying dynamical system that may not be obtained otherwise.
For instance, each time series in the panel may be too short to infer a complex dynamical model, so that inference on an underlying model must combine information across the units.
\panelPomp is, to our knowledge, the first software package specifically addressing these issues.
The utility of \panelPomp has been demonstrated in several scientific applications \citep{ranjeva17,ranjeva19,wale19,domeyer22,lee20}.

The current version of \panelPomp emphasizes simulation-based methods, also known as plug-and-play methods \citep{breto09,he10}, or likelihood-free methods \citep{marjoram03,sisson07}.
Such methods are applicable to dynamic models for which a simulator is available even when the transition densities are unavailable.
This class of flexible algorithms allow researchers to build their models based on scientific reasoning rather than statistical convenience, typically at the expense of computational efficiency.
In the following sections, this tutorial demonstrates how the \panelPomp package can be used to model nonlinear dynamic systems using plug-and-play methodologies.

\section{PanelPOMP models} \label{sec:PanelPOMP}

Panel data is a collection of multiple time series datasets, each possibly multivariate on its own, where each time series is associated with a unit; the units can represent spatial locations, agents in a system, or other units for which data is collected over time.
For convenience of identifying units in the panel, we use numeric labels $\{1,2,\dots,\Unit\}$, which we also write as $1\mycolon\Unit$.
Time series from each unit may be of different lengths, and so we define $N_\unit$ as the number of measurements collected on unit $\unit$.
The observations are modeled as a realization of a stochastic process $Y_{\unit,1:N_\unit}$, observed at times $t_{\unit,1}<t_{\unit,2}<\dots<t_{\unit,N_\unit}$.
An arbitrary realization of the observable process at time $t_{\unit,n}$ is denoted as $y_{\unit,n}$, and the entire collection of data is written as $y^*_{\unit,1:N_{\unit}} = \{y^*_{\unit,1},\dots,y^*_{\unit,N_\unit}\}$, using the asterisk to differentiate the observed data from an arbitrary realization.
The measurement process is assumed to be dependent on a latent Markov process $\{X_\unit(t),t_{\unit,0}\le t\le t_{\unit,N_\unit}\}$ defined subsequent to an initial time $t_{\unit,0}\le t_{\unit,1}$.
Requiring that $\{X_\unit(t)\}$ and $\{Y_{\unit,i},i\neq n\}$ are independent of $Y_{\unit,n}$ given $X_\unit(t_{\unit,n})$, for each $n\in 1\mycolon N_{\unit}$, completes the partially observed Markov process (POMP) model structure for unit~$\unit$.
For a {\PanelPOMP} we require additionally that all units are modeled as independent.

The latent process can be modeled as either a discrete or continuous time process.
For the continuous time process, the value of the latent states at observation times is of particular interest, so we write $X_{\unit,n}=X_\unit(t_{\unit,n})$.
We suppose that $X_{\unit,n}$ and $Y_{\unit,n}$ take values in arbitrary spaces $\Xspace_{\unit}$ and $\Yspace_{\unit}$ respectively, and that $X_{\unit,0:N_\unit}$ and $Y_{\unit,1:N_\unit}$ have a joint density written as $f_{X_{\unit,0:N_\unit}Y_{\unit,1:N_\unit}}(x_{\unit,0:N_\unit},y_{\unit,1:N_\unit}\giventh\theta)$ with dependence on an unknown real-valued parameter vector $\theta\in\RealSpace^{\Thetadim}$.
The transition density
$f_{X_{\unit,n}|X_{\unit,n-1}}(x_{\unit,n}\given x_{\unit,n-1}\giventh\theta)$
and measurement density
$f_{Y_{\unit,n}|X_{\unit,n}}(y_{\unit,n}\given x_{\unit,n}\giventh\theta)$
are permitted to depend arbitrarily on $u$ and $n$, allowing non-stationary models and the inclusion of covariate time series.
The marginal density of $Y_{\unit,1:N_\unit}$ at $y_{\unit,1:N_\unit}$ is $f_{Y_{\unit,1:N_\unit}}(y_{\unit,1:N_\unit}\giventh\theta)$ and the likelihood function for unit $\unit$ is
$\lik_{\unit}(\theta) = f_{Y_{\unit,1:N_\unit}}(y^*_{\unit,1:N_\unit}\giventh\theta)$.
The likelihood for the entire panel is
$\lik(\theta) = \prod_{\unit=1}^{\Unit} \lik_{\unit}(\theta)$,
and any solution $\hat\theta=\arg\max\lik(\theta)$ is a maximum likelihood estimate (MLE).
The log likelihood is $\loglik(\theta)=\log \lik(\theta)$.

We introduce a structure to the parameter space which is not part of the general definition of a PanelPOMP model, but which is sufficiently common to deserve attention.
Suppose the parameter vector can be written as
$\theta=(\shared,\specific_1,\dots,\specific_\Unit)$,
where
\begin{eqnarray}
\label{eq:b1a}
f_{X_{\unit,\time}\vert X_{\unit,\time-1}}(x_{\unit,\time}\given x_{\unit,\time-1} \giventh \theta)
&=&
f_{X_{\unit,\time}|X_{\unit,\time-1}}(x_{\unit,\time}\given x_{\unit,\time-1} \giventh \shared,\specific_\unit)
\\
\label{eq:b1b}
f_{Y_{\unit,\time}|X_{\unit,\time}}(y_{\unit,\time}\given x_{\unit,\time} \giventh \theta) &=& f_{Y_{\unit,\time}|X_{\unit,\time}}(y_{\unit,\time}\given x_{\unit,\time} \giventh \shared,\specific_\unit)
\\
\label{eq:b1c}
f_{X_{\unit,0}}(x_{\unit,0} \giventh \theta) &=& f_{X_{\unit,0}}(x_{\unit,0} \giventh \shared,\specific_\unit)
\end{eqnarray}
Then, $\specific_{\unit}$ is a vector of \emph{unit-specific} parameters for unit $\unit$, and $\shared$ is a \emph{shared} parameter vector.
We suppose $\shared\in\RealSpace^{\Nshared}$ and $\specific\in\RealSpace^{\Nspecific}$, so the dimension of the parameter vector $\theta$ is $\Thetadim=\Nshared+\Nspecific\Unit$.
The collection of unit-specific parameters can be considered as a $\Nspecific\times\Unit$ matrix $[\specific_{\nspecific,\unit}]$.
Determining which parameters should be modeled as unit-specific and which should be shared is often itself an interesting scientific and statistical question.

\begin{table}[t!]
  \begin{center}
    \begin{tabular}{lll}
      \hline
      Method &Mathematical terminology \\
      \hline
      \code{rprocess} &Simulate from $f_{X_{\unit,n}|X_{\unit,n-1}}( x_{\unit,n} \given x_{\unit,n-1}\giventh \shared,\specific_\unit)$\\
      \code{dprocess} &Evaluate $f_{X_{\unit,n}|X_{\unit,n-1}}( x_{\unit,n} \given x_{\unit,n-1}\giventh \shared,\specific_{\unit})$\\
      \code{rmeasure} &Simulate from $f_{Y_{\unit,n}|X_{\unit,n}}( y_{\unit,n} \given x_{\unit,n}\giventh \shared,\specific_\unit)$\\
      \code{dmeasure} &Evaluate $f_{Y_{\unit,n}|X_{\unit,n}}( y_{\unit,n} \given x_{\unit,n}\giventh \shared,\specific_{\unit})$\\
       \code{rinit} &Simulate from $f_{X_{\unit,0}}( x_{\unit,0} \giventh \shared,\specific_\unit)$\\
    \code{rprior} & Simulate from the prior distribution $\pi(\theta)$ \\
    \code{dprior} & Evaluate the prior density $\pi(\theta)$ \\\hline
    \end{tabular}
  \end{center}
  \caption{Basic model components for \code{pomp} units making up a \code{panelPomp}.
    \label{tab:notation}
  }
\end{table}

The \code{panelPomp} class follows the mathematical structure described above, consisting of a list of \code{pomp} objects together with a specification of shared and unit-specific parameters.
The \code{pomp} objects can be built using the \code{pomp()} constructor function from the \pomp \R package \citep{king16}.
These objects are bound into a \code{panelPomp} object by the constructor function \code{panelPomp()}.
The general framework does not insist that units of a PanelPOMP share observation times or other model features---though any additional shared structure may simplify the specification of the list of constituent \code{pomp} objects.
The specification of \code{pomp} models was discussed by \citet{king16}, and open-source examples are available online for diverse applications including those described in Section~\ref{sec:examples}.
Briefly, the model is specified by writing code to evaluate some or all of the following basic model components described in Table~\ref{tab:notation}.

Algorithms written for \panelPomp may access these functions.
An algorithm is defined to be plug-and-play if it does not require \code{dprocess}.
A \code{pomp} or \code{panelPomp} object does not need to have all the basic computations defined.
In particular, if employing plug-and-play methodology there is no need to specify \code{dprocess}.
Some algorithms may require model components beyond those tabulated above.
For example, the \code{parameter\_trans} function defines parameter transformations which may be carried out to facilitate model fitting by removing boundaries and/or shifting to a natural scale scale for exploring additive perturbations.
In addition, Bayesian methods may call \code{rprior} or \code{dprior} if these have been defined.

A simple example of a {\PanelPOMP} is a stochastic version of the discrete-time Gompertz model for biological population growth \citep{winsor32}.
This model supposes that the density, $X_{\unit,n+1}$, of a population $\unit$ at time $n+1$ depends on the density, $X_{\unit,n}$, at time $n$ according to
\begin{equation}
\label{eq:gompertz1}
X_{\unit,n+1}=\kappa_\unit^{1-e^{-r_\unit}}\,X_{\unit,n}^{e^{-r_\unit}}\,\varepsilon_{\unit,n}.
\end{equation}
In \eqref{eq:gompertz1}, $\kappa_\unit$ is the carrying capacity of population $\unit$, $r_\unit$ is a positive parameter, and $\{\varepsilon_{\unit,n},\unit\in 1\mycolon\Unit,n\in 1\mycolon N_\unit\}$ are independent and identically-distributed lognormal random variables with $\log\varepsilon_{\unit,n}\sim\normal(0,\sigma_{\mathrm{G},\unit}^2)$.
We suppose the population is observed with lognormally distributed errors,
\begin{equation}
\label{eq:gompertz-obs}
\nonumber
\log{Y_{\unit,n}}\;\sim\;\normal\left(\log{X_{\unit,n}},\tau_\unit^2\right).
\end{equation}
This is accessible via
<<gomp, echo=TRUE>>=
gomp <- panelGompertz(N = 100, U = 50)
@
\noindent Here, the number of units is \code{length(gomp)=\Sexpr{length(gomp)}}.
\panelPomp uses S4 classes \citep{chambers98,genolini08} with \code{gomp} having the base class \code{panelPomp}.
Because data are a key component of PanelPOMP models, the \code{panelGompertz} function first creates a PanelPOMP model, and then generates a dataset by simulating from that model using a reproducible seed specified by the \code{seed} argument to the function.

<<plot-gomp,echo=F,eval=T,fig.width=5,fig.height=5,fig.show='hide'>>=
plot(gomp[1:2])
@

\begin{figure}
\begin{center}
\resizebox{3in}{!}{\includegraphics{figure/plot-gomp-1}}
\resizebox{3in}{!}{\includegraphics{figure/plot-gomp-2}}
\caption{Separate plots produced by \code{plot(gomp[1:2])}.}
\label{fig-plot-gomp}
\end{center}
\end{figure}

Commonly, the first thing to do with a new object is to plot it, and Fig.~\ref{fig-plot-gomp} demonstrates the panelPomp \code{plot} method applied after subsetting \code{gomp}.
The units of a panelPomp do not necessarily share the same variables, so in general a sequence of separate plots is all that can be offered.
It may happen that the units can meaningfully be plotted on the same axis, and that can be achieved by coercing the \code{panelPomp} object to a \code{pompList} and using the \code{plot} method for that class (Fig.~\ref{fig:plot-gomp-pompList}).
A third option is to export the \code{panelPomp} object via \code{as(gomp,"data.frame")} and work this this to produce customized plots.

<<plot-gomp-pompList,echo=FALSE,fig.cap="Overlayed time series plot using \\code{plot(as(gomp,'pompList')).}">>=
par(mai=c(0.8,0.8,0.1,0.1))
plot(as(gomp,"pompList"))
@

A basic operation is simulation.
We can generate another simulation with the same parameter values:
<<sim-gomp,echo=TRUE>>=
gomp2 <- simulate(gomp)
@
\noindent We can simulate from the same model at new parameter values by giving additional arguments to \code{simulate}.
There are two different representations of parameters within \panelPomp which are convenient in different situations.
The unit-specific parameters are naturally represented as a matrix, set with the \code{specific} argument in the \code{panelPomp} constructor function, with a column for each units and a row for each parameter.
Similarly, the shared parameters are a named vector that can be set using the \code{shared} argument.
Alternatively, we can consider the parameters as a single named vector, with a naming convention that \code{"beta[unit7]"} is the name of the unit-specific parameter \code{beta} for unit $u=7$.
Model parameters can be extracted and set in this vector-format using the functions \code{coef()} and \code{coef()<-}, respectively.
Alternatively, unit-specific and shared parameters can be extracted using functions \code{specific()} and \code{shared()}, and modified using the equivalent setter functions \code{specific()<-} and \code{shared()<-}.
For example, all shared and a subset of unit-specific parameters (from units 1--3) can be extracted in vector format via
<<coef,echo=T>>=
coef(gomp[1:3])
@
\noindent or in a list format using the \code{format = `list'} argument
<<pparams,echo=T>>=
coef(gomp[1:3], format = 'list')
@
\noindent The functions \code{toParamList} and \code{toParamVec} facilitate movement between the vector and list formats
<<toParamList,echo=T>>=
toParamList(coef(gomp[1:3]))
@

\panelPomp seeks to avoid unnecessary duplication with \pomp.
Thus, \panelPomp requires that \pomp is loaded and builds on existing functionality of \pomp where possible.
In particular, a list of \code{pomp} objects for each unit can be extracted from a \code{panelPomp} object via
<<,echo=T,eval=F>>=
as(panelPompObject,"list")
@
Some methods in the \pkg{pomp} package take advantage of a \code{pompList} class which is defined as a list of \code{pomp} objects.
These methods can be accessed via
<<,echo=T,eval=F>>=
as(panelPompObject,"pompList")
@
Many critical issues in computational performance of the basic model components for \panelPomp, and utilities for assisting with the user specification of the model, have already received extensive development and testing in the context of \pomp.
All the facilities for constructing POMP models in \pomp are available for constructing the models for each unit in \panelPomp.
This article avoids duplication by referring the reader to \citet{king16} and the \pomp documentation for detailed discussion of constructing \code{pomp} objects.
In Section~\ref{sec:examples}, we identify some case studies that provide useful code for scientific applications of \panelPomp.
In Section~\ref{sec:meth}, we proceed to demonstrate inference for \code{panelPomp} objects, emphasizing methodological issues arising due to the specific requirements of panel data,  in the context of a toy example.

\section{Implementing mechanistic models: case studies}
\label{sec:examples}

Developing mechanistic statistical models for new scientific applications requires identifying the essential variables and their functional relationships, and obtaining a satisfactory description of stochasticity in both the measurement process and the system dynamics.
This challenging but valuable exercise is assisted by simulation-based software that permits implementation of a general class of models.
Once a suitable model is found, it provides a testable benchmark for subsequent investigations of the system under study and other comparable systems.
Published models and methods, equipped with data and reproducible source code, are essential to maintain this progressive development.

Since each unit in a  \code{panelPomp} is itself a \code{pomp}, we refer to \citet{king16} for full details of how these are specified, and we focus on the new issues arising in \code{panelPomp}.
Recall from Section~\ref{sec:PanelPOMP} that a \code{panelPomp} is constructed from the list of constituent \code{pomp} models together with a collection of shared and unit-specific parameters.
A unit-specific parameter named \code{theta} should be called \code{theta} in each constituent \code{pomp}.
Thus, the value \code{theta[unit7]} specific to unit 7 is just passed as \code{theta} when required by the \code{pomp} model representing this unit.

Existing examples of \code{panelPomp} analysis have primarily concerned infectious disease dynamics, a topic that has motivated many advances in inference for partially observed stochastic dynamic systems.
We discuss five of these below.
In addition, the close relationship between \code{panelPomp} and \code{pomp} objects means that \code{panelPomp} model constructions can borrow from the considerable existing resources for \pomp.
The remaining examples give some applications in other domains which have been carried out using \code{pomp} models but have extensions to \code{panelPomp} situations.

\begin{enumerate}
\example{Sexual contacts: behavioral heterogeneity within and between individuals}.
\citet{romero-severson15} developed a PanelPOMP model to investigate a longitudinal prospective survey of sexual contacts, quantifying the roles of behavioral differences between individuals and differences within an individual over time. The \code{contacts()} function in \panelPomp generates one of the models and datasets studied in this paper.
The source code to generate this \code{panelPomp} object is at \url{https://github.com/cbreto/panelPomp}.


\example{Recurrent infection with HPV}.
\citet{ranjeva17} developed a PanelPOMP model to study the strain dynamics of a longitudinal prospective serological survey of human papillomavirus (HPV).
Their \panelPomp code is available at \url{https://github.com/cobeylab/HPV-model}.

\example{Polio: asymptomatic infection and local extinction}.
\citet{martinez-bakker15} developed a POMP model for polio transmission to investigate the pre-vaccination epidemics in USA, fitting all parameters separately for each state.
\citet{breto19} found additional precision in inferences when the states are combined into a PanelPOMP with some shared parameters.
The \code{polio()} function in \panelPomp generates this model, and the source code is at \url{https://github.com/cbreto/panelPomp}.

\example{Age-specific differences in the dynamics of protective immunity to influenza}.
\citet{ranjeva19} developed a PanelPOMP model to interpret longitudinal study of serological measurements on human influenza immunity.
The source code for their \panelPomp model is at \url{https://github.com/cobeylab/Influenza-immune-dynamics}.

\example{The dynamic struggle between malaria and the immune system}.
\citet{wale19} developed a PanelPOMP model to investigate the dynamics of the immune response to malaria, based on flow cytometry time series for a panel of mice under varying treatments. Their \code{panelPomp} source code and data are available at \url{https://doi.org/10.5061/dryad.nk98sf7pk}.

\example{Ecological predator-prey dynamics: consumptive and non-consumptive effects}.
\citet{marino19} developed a stochastic seasonal predator-prey POMP model to investigate the relationship between an abundant zooplankton species, {\it Daphnia mendotae}, and its predator, {\it Bythotrephes longimanus}, in Lake Michigan. The source code for the \code{pomp} analysis is available at \url{https://doi.org/10.5061/dryad.bh688ft}.

\example{Stochastic volatility and financial leverage}.
 \citet{breto14} demonstrated the applicability of plug-and-play methods within \pomp to investigate stochastic volatility in finance using a POMP model for a single index.

\end{enumerate}

Many other POMP models implemented using \code{pomp} are presented at \url{https://kingaa.github.io/pomp/biblio.html}.


\section{Methodology for PanelPOMP models} \label{sec:meth}

All POMP methods can in principle be extended to PanelPOMPs since a PanelPOMP can be written as a POMP.
Three different ways to represent a PanelPOMP as a POMP were identified by \citet{romero-severson15}:
(i) the panels can be concatenated temporally into a long time series; (ii) the panels can be adjoined to form a high-dimensional POMP with a latent state comprised of a vector of latent states for each unit; (iii) time in the POMP representation can correspond to unit, $u$, with a vector valued state representing the full process for this unit.
The existence of these representations does not necessarily imply that POMP methods will be computationally feasible on the resulting PanelPOMP.
In particular, sequential Monte Carlo algorithms can have prohibitive scaling difficulties with the high dimensional latent states that can be involved with representations (ii) and (iii).

Here, we focus on describing and demonstrating the plug-and-play likelihood-based inference workflow used in the scienfic examples of Section~\ref{sec:examples}.
This approach builds on likelihood evaluation via the particle filter using \code{pfilter()} and likelihood maximization via iterated filtering using \code{mif2()}.
These algorithms can be formally justified in terms of representation (i) above \citep{breto19}, though the numerical implementation does not in practice have to explicitly construct the concatenation of the \code{panelPomp} object into a \code{pomp} object.

\subsection{Log likelihood evaluation via panel particle filtering}

The particle filter, also known as sequential Monte Carlo, is a standard tool for log likelihood evaluation on non-Gaussian POMP models.
The log likelihood function is a central component of Bayesian and frequentist inference.
Due to the dynamic independence assumed between units, particle filtering can be carried out separately on each unit.
The \code{pfilter} method for \code{panelPomp} objects is therefore a direct extension of the \code{pfilter} method for \code{pomp} objects from the \pomp package.
Repeating \code{pfilter} is advisable to reduce the Monte Carlo error on the log likelihood evaluation and to quantify this error.
The following code carries out replicated evaluations of the log likelihood of \code{gomp}, taking advantage of multicore computation.
The Gompertz model is a convenient for testing methodology for nonlinear non-Gaussian models since it has a logarithmic transformation to a linear Gaussian process and therefore the exact likelihood is computable by the Kalman filter \citep{king16}.

<<pf_core,eval=F,echo=T>>=
pf_results <- foreach(i=1:10) %dopar% pfilter(gomp,
  Np=switch(run_level,10,200,1000))
@

<<pf_loglik1,eval=F,echo=F>>=
lambda_1 <- logmeanexp(sapply(pf_results,logLik),se=TRUE)
@

<<pf_loglik2,eval=F,echo=F>>=
lambda_2 <- panel_logmeanexp(sapply(pf_results,unitlogLik),
  MARGIN=1,se=TRUE)
@

<<loglik_exact,eval=T,echo=F>>=
lambda_exact <- panelGompertzLikelihood(coef(gomp),gomp,coef(gomp))
@

<<pf_eval,echo=F,eval=T>>=
stew(file=paste0(rda_dir,"pf.rda"),{
<<pf_core>>
<<pf_loglik1>>
<<pf_loglik2>>
  if(!VERBOSE) rm("pf_results")
})
load(paste0(rda_dir,"pf.rda")) # to access system time
pf_time <- .system.time
@
This took \Sexpr{myRound(pf_time["elapsed"]/60,2)} minutes using \Sexpr{cores} cores, resulting in a list of objects of class \code{pfilterd.ppomp}.
We can use \code{logLik} to extract the Monte Carlo likelihood esimate $\loglik^{[\nrep]}$ for each replicate $\nrep$, and \code{unitlogLik}  to extract the vector of component Monte Carlo likelihood esimates $\loglik^{[\nrep]}_{\unit}$ for each unit $\unit=1,\dots,\Unit$, where $\loglik^{[\nrep]}=\sum_{\unit=1}^{\Unit}\loglik^{[\nrep]}_{\unit}$.
For a POMP model, replicated particle filter likelihood evaluations are usually averaged on the natural scale, rather than the log scale, to take advantage of the unbiasedness of the particle filter likelihood estimate.
Thus, we have
\[
\hat\loglik_1 = \log \frac{1}{\Nrep}\sum_{\nrep=1}^{\Nrep}
\exp
\left\{
  \sum_{\unit=1}^{\Unit} \loglik^{[\nrep]}_{\unit}
\right\}
\]
which can be implemented as
<<,echo=T,eval=F>>=
<<pf_loglik1>>
@
giving $\hat\loglik_1=\Sexpr{myRound(lambda_1[1],1)}$ with a jack-knife standard error of $\Sexpr{myRound(lambda_1[2],1)}$.
Taking advantage of the independence of the units in the panel structure, \citet{breto19} showed it is preferable to average the replicates of marginal likelihood for each unit before taking a product over units.
This corresponds to
\[
\hat\loglik_2 = \log \prod_{\unit=1}^\Unit \frac{1}{\Nrep}\sum_{\nrep=1}^{\Nrep}  \exp \big\{ \hat \loglik^{[\nrep]}_{\unit} \big\}
\]
which can be implemented as
<<,echo=T,eval=F>>=
<<pf_loglik2>>
@
giving $\hat\loglik_2=\Sexpr{myRound(lambda_2[1],1)}$ with a jack-knife standard error of $\Sexpr{myRound(lambda_2[2],1)}$.
For this model, a Kalman filter likelihood evaluation gives an exact answer, $\loglik=\Sexpr{myRound(lambda_exact,1)}$.

\subsection{Maximum likelihood estimation via Panel Iterated Filtering} \label{sec:pif}

Iterated filtering algorithms carry out repeated particle filtering operations on an extended version of the model that includes time-varying perturbations of parameters.
At each iteration, the magnitude of the perturbations is decreased, and in a suitable limit the algorithm approaches a local maximum of the likelihood function.
The IF2 iterated filtering algorithm \citep{ionides15} has been used for likelihood-based inference on various POMP models arising in epidemiology and ecology \citep[reviewed by][]{breto18}, superseding the previous IF1 algorithm of \citet{ionides06}.
IF2 is implemented in \pomp as the \code{mif2} method for class \code{pomp}.
A panel iterated filtering (PIF) algorithm, extending IF2 to panel data, was developed by \citet{breto19}.
An implementation of PIF in \panelPomp is provided by the \code{mif2} method for class \code{panelPomp}, following the pseudocode in Algorithm~\ref{alg:pif}.
The pseudocode in  Algorithm~\ref{alg:pif} sometimes omits explicit specification of ranges over which variables are to be computed when this is apparent from the context:
it is understood that $\np$ takes values in $\seq{1}{\Np}$, $\nshared$ in
$\seq{1}{\Nshared}$ and $\nspecific$ in $\seq{1}{\Nspecific}$.
The $N[0,1]$ notation corresponds to the construction of independent standard normal random variables, leading to to Gaussian perturbations of parameters on a transformed scale.
These perturbations could follow an arbitrary distribution within the theoretical frameworks of IF2 and PIF.


\begin{algorithm}[t!]
  \caption{
%    \textbf{Panel iterated filtering}.
    \texttt{mif2$\big($pp, Nmif{\argequals}$M$, Np{\argequals}$J$,
start{\argequals}$(\shared^0_{\nshared},\specific^0_{\nspecific,\unit})$,
rw\_sd{\argequals}$(\sigma^\Shared_{\nshared,\time},\sigma^\Specific_{\nspecific,\unit,\time})$,
cooling.factor.50{\argequals}$\rho^{50}\big)$}, where \code{pp} is a \code{panelPomp} object containing data and defined \code{rprocess}, \code{dmeasure}, \code{rinit} and \code{partrans} components.
    \label{alg:pif}
    }
\noindent\begin{tabular}{ll}
{\bf input:}\rule[-1.5mm]{0mm}{6mm}
& Data, $y_{\unit,n}^*$, $u$ in $\seq{1}{U}$, $n$ in $\seq{1}{N}$\\
& Simulator of initial density, $f_{X_{\unit,0}}(x_{\unit,0}\giventh \shared,\specific_{\unit})$ \\
& Simulator of transition density, $f_{X_{\unit,n}|X_{\unit,n-1}}(x_{\unit,n}\given x_{\unit,n-1}\giventh \shared,\specific_{\unit})$ \\
& Evaluator of measurement density, $f_{Y_{\unit,n}|X_{\unit,n}}(y_{\unit,n}\given x_{\unit,n}\giventh\shared,\specific_{\unit})$ \\
& Number of particles, $J$, and number of iterations, $\Nmif$\\
& Starting shared parameter swarm, $\Shared^0_{\nshared,\np}=\shared^0_{\nshared}$, $a$ in $\seq{1}{A}$, $j$ in $\seq{1}{J}$\\
& Starting unit-specific parameter swarm, $\Specific^0_{\nspecific,\unit,\np}=\specific^0_{\nspecific,\unit}$,  $b$ in  $\seq{1}{B}$, $j$ in $\seq{1}{J}$\\
& Random walk intensities,
$\sigma^\Shared_{\nshared,\time}$ and $\sigma^\Specific_{\nspecific,\unit,\time}$ \\
& Parameter transformations, $h^{\Shared}_{\nshared}$ and $h^{\Specific}_{\nspecific}$, with inverses
 $\big(h^{\Shared}_{\nshared}\big)^{-1}$ and $\big(h^{\Specific}_{\nspecific}\big)^{-1}$
\\
{\bf output:}\rule[-1.5mm]{0mm}{6mm}
& Final parameter swarm, $\Shared^M_{\nshared,\np}\;$ and $\;\Specific^M_{\nspecific,\unit,\np}$
\rule[-2mm]{0mm}{5mm}
\end{tabular}

\hrule

\noindent\begin{tabular}{l}
For $\nmif$ in $1\mycolon M$\rule[0mm]{0mm}{5mm}\\
\asp $\Shared^m_{\nshared,0,\np}=\Shared^{m-1}_{\nshared,\np}$
% and $\Specific^m_{\nspecific,\unit,0,\np}=\Specific^{m-1}_{\nspecific,\unit,\np}$
\mystretch\\
\asp For $\unit$ in $1\mycolon \Unit$\\
\asp \asp $\Shared^{F,m}_{\nshared,\unit,0,j} =\big(h^{\Shared}_{\nshared}\big)^{-1}
  \left(
  h^\Shared_\nshared \big(\Shared^{m}_{\nshared,\unit-1,\np}\big)+
    \rho^{m}\sigma^{\Shared}_{\nshared,0} Z^{\Shared,m}_{\nshared,\unit,0,\np}
  \right)$ for $ Z^{\Shared,m}_{\nshared,\unit,0,\np}\sim N[0,1]$ \myBigStretch\\
\asp \asp $\Specific^{F,m}_{\nspecific,\unit,0,j} =\big(h^{\Specific}_{\nspecific}\big)^{-1}
  \left(
  h^\Specific_\nspecific \big(\Specific^{m-1}_{\nspecific,\unit,\np}\big)+
    \rho^{m}\sigma^{\Specific}_{\nspecific,u,0} Z^{\Specific,m}_{\nspecific,\unit,0,\np}
  \right)$ for $ Z^{\Specific,m}_{\nspecific,\unit,0,\np}\sim N[0,1]$ \myBigStretch\\
\asp \asp $X_{\unit,0,j}^{F,m}\sim f_{X_{\unit,0}}
  \left(
    x_{\unit,0} \; \giventh \; \Shared^{F,m}_{\nshared,\unit,0,j} ,
    \Specific^{F,m}_{\nspecific,\unit,0,j}
  \right)$ \myBigStretch\\
\asp \asp For $n$ in $1\mycolon N_{\unit}$\\
\asp \asp \asp $\Shared^{P,m}_{\nshared,\unit,\time,j} =\big(h^{\Shared}_{\nshared}\big)^{-1}
  \left(
  h^\Shared_\nshared \big(\Shared^{F,m}_{\nshared,\unit,\time-1,\np}\big)+
    \rho^{m}\sigma^{\Shared}_{\nshared,\time} Z^{\Shared,m}_{\nshared,\unit,\time,\np}
  \right)$ for $ Z^{\Shared,m}_{\nshared,\unit,\time,\np}\sim N[0,1]$ \myBigStretch\\
\asp \asp \asp $\Specific^{P,m}_{\nspecific,\unit,\time,j} =\big(h^{\Specific}_{\nspecific}\big)^{-1}
  \left(
  h^\Specific_\nspecific \big(\Specific^{F,m}_{\nspecific,\unit,\time-1,\np}\big)+
    \rho^{m}\sigma^{\Specific}_{\nspecific,u,\time} Z^{\Specific,m}_{\nspecific,\unit,\time,\np}
  \right)$ for $ Z^{\Specific,m}_{\nspecific,\unit,\time,\np}\sim N[0,1]$ \myBigStretch\\
\asp \asp \asp $X_{\unit,n,j}^{P,m}\sim f_{X_{\unit,n}|X_{\unit,n-1}}
   \left(
     x_{\unit,n} \; \big| \; X^{F,m}_{\unit,n-1,j} \; \giventh \;
     \Shared^{P,m}_{\nshared,\unit,\time,j} \, ,
     \Specific^{P,m}_{\nspecific,\unit,\time,j}
   \right)$  \myBigStretch\\
\asp \asp \asp $w_{\unit,n,j}^m = f_{Y_{\unit,n}|X_{\unit,n}}
    \left(y^*_{\unit,n} \; \big| \; X_{\unit,n,j}^{P,m} \; \giventh \;
       \Shared^{P,m}_{\nshared,\unit,\time,j} \, ,
       \Specific^{P,m}_{\nspecific,\unit,\time,j}
    \right)$  \myBigStretch\\
\asp \asp \asp Draw $k_{1:J}$ with $\prob(k_j=i)=  w_{\unit,n,i}^m\Big/\sum_{q=1}^J w_{\unit,n,q}^m$ \myBigStretch \\
\asp \asp \asp $\Shared^{F,m}_{\nshared,\unit,\time,\np}=\Shared^{P,m}_{\nshared,\unit,\time,k_{\np}}$,  $\;\; \Specific^{F,m}_{\nspecific,\unit,\time,\np}=\Specific^{P,m}_{\nspecific,\unit,\time,k_{\np}} \;$
and $\; X^{F,m}_{\unit,n,j}=X^{P,m}_{\unit,n,k_j}$   \mystretch\\
\asp \asp End For \\ %%% end n loop
\asp \asp  $\Shared^{m}_{\nshared,\unit,\np}=\Shared^{F,m}_{\nshared,\unit,N_{\unit},\np}$ and
           $\Specific^{m}_{\nspecific,\unit,\np}=\Specific^{F,m}_{\nspecific,\unit,N_{\unit},\np}$
 \\
\asp End For \\ %%% end u loop
\asp $\Shared^{m}_{\nshared,\np}=\Shared^m_{\nshared,\Unit,\np}$
\\
End For \\ %%% end m loop
\end{tabular}
\end{algorithm}

At a conceptual level, the PIF algorithm has an evolutionary analogy: successive iterations mutate parameters and select among the fittest outcomes measured by Monte Carlo likelihood evaluation.
The theory allows considerable flexibility in how the parameters are perturbed, but Gaussian perturbations on an appropriate scale are typically adequate.
Most often, the perturbation parameters
$\sigma^\Shared_{\nshared,\time}$ and $\sigma^\Specific_{\nspecific,\unit,\time}$ in Algorithm~\ref{alg:pif} will not depend on $\time$.
For parameters set to have uncertainty on a unit scale, the value 0.02 demonstrated here has been commonly used.
The help documentation on the \code{rw\_sd} argument gives instruction on using additional structure should it become necessary.

For positive parameters, a logarithmic transform can achieve both tasks of removing the boundary and placing uncertainty on a unit scale.
For the panel Gompertz model, all the parameters are non-negative valued, and so the \code{panelGompertz()} code calls \code{panelPomp} with an argument
<<,eval=F,echo=T>>=
partrans=parameter_trans(log=c("K","r","sigma","tau","X.0"))
@
Inference methodology can call \code{partrans(...,dir="toEst")} to work with parameters on a suitable scale, usually one where additive variation is meaningful.
The methodology can revert to the original parameterization, presumably chosen to be scientifically convenient or meaningful, using  \code{partrans(...,dir="fromEst")}.
Thus, a user who does not have to look `under the hood' never has to be directly concerned with parameters on the transformed scale, beyond assigning the transformation.

For Monte Carlo maximization, replication from diverse starting points is recommended.
We demonstrate such a maximization search on \code{gomp}.
For simplicity, we fix $K_{\unit}=1$ and the initial condition $X_{\unit,0}=1$, maximizing over two shared parameters, $r$ and $\sigma$, and one unit-specific parameter $\tau_\unit$.
To define the diverse starting points, we make uniform draws from a specified box.
We are not promising that the search will stay within this box, and indeed we should be alert to the possibility that the data lead us elsewhere.
However, if replicated searches started from this box reliably reach a consensus, we claim we have carefully investigated this part of parameter space.
A larger box leads to greater confidence that the relevant part of the parameter space has been searched, at the expense of requiring additional work.
The \code{runif\_panel\_design} function constructs a matrix of random draws from the box.
<<box,echo=T,eval=T>>=
starts <- runif_panel_design(
  lower = c('r' = 0.05, 'sigma' = 0.05, 'tau' = 0.05, 'K' = 1, 'X.0' = 1),
  upper = c('r' =  0.2, 'sigma' =  0.2, 'tau' =  0.2, 'K' = 1, 'X.0' = 1),
  specific_names = c('K', 'tau', 'X.0'),
  unit_names = names(gomp),
  nseq=switch(run_level,2,4,6)
)
@

We then carry out a search from each starting point:

<<mif_core,echo=T,eval=F>>=
mif_results <- foreach(start=iter(starts,"row")) %dopar% {
  mif2(gomp, start=unlist(start),
    Nmif = switch(run_level,2,20,150),
    Np = switch(run_level,10,500,1500),
    cooling.fraction.50=0.5,
    cooling.type="geometric",
    transform=TRUE,
    rw.sd=rw_sd(r=0.02,sigma=0.02,tau=0.02)
  )
}
@

<<mif_eval,echo=F,eval=T>>=
stew(file=paste0(rda_dir,"mif.rda"),{
<<mif_core>>
})
load(file=paste0(rda_dir,"mif.rda"))
mif_time <- .system.time
@

This took \Sexpr{myRound(mif_time["elapsed"]/60,1)} minutes using \Sexpr{cores} cores, producing a list of objects of class \code{mifd.ppomp}.
The algorithmic parameters are very similar to those of the \code{mif2} method for class \code{pomp}.
The perturbations, determined by the \code{rw\_sd} argument, may be a list giving separate instructions for each unit.
When only one specification for a unit-specific parameter is given (as we do for $K_\unit$ here) the same perturbation is used for all units.

We can check on convergence of the searches, and possibly diagnose improvements in the choices of algorithmic parameters, by consulting trace plots of the searches available via the \code{traces} method for class \code{mifd.ppomp}.
This follows recommendations by \citep{ionides06} and \citep{king16}.

An issue characteristic of PanelPOMP models is using the panel structure to facilitate the large number of parameters arising when unit-specific parameters are specified for a large number of units.
For a fixed value of the shared parameters, the likelihood of the unit-specific parameters factorizes over the units.
The factorized likelihood can be maximized separately over each unit, replacing a challenging high-dimensional problem with many relatively routine low-dimensional problems.
This suggests a block maximization strategy where unit-specific parameters for each unit are maximized as a block.
\citet{breto19} used a simple block strategy where a global search over all parameters is followed by a block maximization over units for unit-specific parameters.
We demonstrate this here, refining each of the maximization replicates above.
The following function carries out a maximization search of unit-specific parameters for a single unit.
The call to \code{mif2} takes advantage of argument recycling: all algorithmic parameters are re-used from the construction of \code{mifd\_gomp} except for the respecified random walk standard deviations which ensures that only the unit-specific parameters are perturbed.

<<block_func,eval=T,echo=T>>=
mif_unit <- function(unit,mifd_gomp,reps=switch(run_level,2,4,6)){
  unit_gomp <- unit_objects(mifd_gomp)[[unit]]
  mifs <- replicate(n=reps,mif2(unit_gomp,rw.sd=rw_sd(tau=0.02)))
  best <- which.max(sapply(mifs,logLik))
  coef(mifs[[best]])["tau"]
}
@

Now we apply this block maximization to find updated unit-specific parameters for each replicate, and we insert these back into the \code{panelPomp}

<<block_core,eval=F,echo=T>>=
mif_block <- foreach(mf=mif_results) %dopar% {
  mf@specific["tau",] <- sapply(1:length(mf),mif_unit,mifd_gomp=mf)
  mf
}
@

<<block_eval,echo=F,eval=T>>=
stew(file=paste0(rda_dir,"block.rda"),{
<<block_core>>
})
load(file=paste0(rda_dir,"block.rda"))
block_time <- .system.time
@

This took \Sexpr{myRound(block_time["elapsed"]/60,1)} minutes.

We expect Monte Carlo estimates of the maximized log likelihood functions to fall below the actual (usually unknown) value.
This is in part because imperfect maximization can only reduce the maximized likelihood, and in part a consequence of Jensen's inequality applied to the likelihood evaluation: the unbiased SMC likelihood evaluation has a negative bias on estimation of the log likelihood.

\subsection{Monte Carlo profile likelihood}

The profile likelihood function is constructed by fixing one focal parameter at a range of values and then maximizing the likelihood over all other parameters for each value of the focal parameter.
Constructing a profile likelihood function has several practical advantages.
\begin{enumerate}
\item Evaluations at neighboring values of the focal parameter provide additional Monte Carlo replication. Typically, the true profile log likelihood is smooth, and asymptotically close to quadratic under regularity conditions, so deviations from a smooth fitted line can be interpreted as Monte Carlo error.
\item Large-scale features of the profile likelihood reveal a region of the parameter space outside which the model provides a poor explanation of the data.
\item Co-plots, showing how the values of other maximized parameters vary along the profile, may provide insights into parameter tradeoffs implied by the data.
\item The smoothed Monte Carlo profile log likelihood can be used to construct an approximate 95\% confidence interval.
The resulting confidence interval can be properly adjusted to accommodate both statistical and Monte Carlo uncertainty \citep{ionides17}.
\end{enumerate}

Once we have code for maximizing the likelihood, only minor adaptation is needed to carry out the maximizations for a profile.
The \code{runif\_panel\_design} generating the starting values is replaced by a call to \code{profile\_design}, which assigns the focal parameter to a grid of values and randomizes the remaining parameters.
The random walk standard deviation for the focal parameter is unassigned, which leads it to be set to zero and therefore the parameter remains fixed during the maximization process.
The following code combines the joint and block maximizations developed above.


<<profile_core,echo=T,eval=F>>=
# Names of the estimated parameters
estimated <- c(
  "r", "sigma", paste0("tau[unit", 1:length(gomp), "]")
)

# Names of the fixed parameters (not estimated)
fixed <- names(coef(gomp))[!names(coef(gomp)) %in% estimated]

profile_starts <- profile_design(
  r = seq(0.05, 0.2, length = switch(run_level, 10, 10, 20)),
  lower = c(coef(gomp)[estimated] / 2, coef(gomp)[fixed])[-1],
  upper = c(coef(gomp)[estimated] * 2, coef(gomp)[fixed])[-1],
  nprof = 2, type = "runif"
)

profile_results <- foreach(start=iter(profile_starts,"row")) %dopar% {
  mf <- mif2(
    mif_results[[1]],
    start = unlist(start),
    rw.sd = rw_sd(sigma = 0.02, tau = 0.02))
  mf@specific["tau", ] <- sapply(1:length(mf), mif_unit,mifd_gomp = mf)
  mf
}
@

<<profile_eval,echo=F,eval=T>>=
stew(file=paste0(rda_dir,"profile.rda"),{
<<profile_core>>
})
load(file=paste0(rda_dir,"profile.rda"))
profile_time <- .system.time
@


The profile searches took \Sexpr{myRound(profile_time["elapsed"]/60,1)} minutes.
However, we are not quite done gathering the results for the profile.
The perturbed filtering carried out by \code{mif2} leads to an approximate likelihood evaluation, but for our main results it is better to re-evaluate the likelihood without perturbations.
Also, replication is recommended to reduce and quantify Monte Carlo error.
We do this, and tabulate the results.

<<profile_table_core,eval=F,echo=T>>=
profile_table <- foreach(mf=profile_results,.combine=rbind) %dopar% {
  LL <- replicate(switch(run_level,2,5,10),
    logLik(pfilter(mf,Np=switch(run_level,10,500,2500)))
  )
  LL <- logmeanexp(LL,se=TRUE)
  data.frame(t(coef(mf)),loglik=LL[1],loglik.se=LL[2])
}
@


<<profile_table_eval,echo=F,eval=T>>=
stew(file=paste0(rda_dir,"profile_table.rda"),{
<<profile_table_core>>
})
load(file=paste0(rda_dir,"profile_table.rda"))
profile_table_time <- .system.time
@


The likelihood evaluations took \Sexpr{myRound(profile_table_time["elapsed"]/60,1)} minutes.
It is appropriate to spend comparable time evaluating the likelihood to the time spent maximizing it: a high quality maximization without high quality likelihood evaluation is hard to interpret, whereas good evaluations of the likelihood in a vicinity of the maximum can inform about the shape of the likelihood surface in this region which may be as relevant as knowing the exact maximum.

The Monte Carlo adjusted profile (MCAP) approach of \citet{ionides17} is implemented by the \code{mcap()} function in \pomp.
This function constructs a smoothed profile likelihood, by application of the \code{loess} smoother.
It computes a local quadratic approximation that is used to derive an extension to the classical profile likelihood confidence interval that makes allowance for Monte Carlo error in the calculation of the profile points.
Theoretically, an MCAP procedure can obtain statistically efficient confidence intervals even when the Monte Carlo error in the profile likelihood is asymptotically growing and unbounded \citep{ning21}.
Log likelihood evaluation has negative bias, as a consequence of Jensen's inequality for an unbiased likelihood estimate.
This bias produces a vertical shift in the estimated profile, which fortunately does not have consequence for the confidence interval if the bias is slowly varying.

<<profile_kalman,echo=F,eval=T>>=
profile_r <- unique(profile_starts[,"r"])
start_matrix <- matrix(coef(gomp),ncol=length(coef(gomp)),
  nrow=length(profile_r),byrow=T,dimnames=list(NULL,names(coef(gomp))))
start_matrix[,"r"] <- profile_r
estNames <- c("sigma",paste0("tau[unit",1:length(gomp),"]"))
stew(file=paste0(rda_dir,"profile_kalman.rda"),{
  exact_profile <- foreach(start=iter(start_matrix,"row")) %dopar% {
    x <- as.vector(start)
    names(x) <- colnames(start)
    optim(
      par=x[estNames],
      fn=panelGompertzLikelihood,
      panelPompObject=gomp,
      params=x,
      hessian=FALSE,
      control=list(trace=0,fnscale=-1)
    )
  }
})
load(file=paste0(rda_dir,"profile_kalman.rda"))
exact_profile_time <- .system.time
exact_profile_table <- cbind(r=profile_r,
  logLik=sapply(exact_profile,function(x) x$value))
@

The profile points evaluated above, and stored in \code{profile\_table}, can be used to compute a 95\% MCAP confidence interval as follows:
<<mcap,echo=T,eval=T>>=
gomp_mcap <- pomp::mcap(logLik=profile_table$loglik,
  parameter=profile_table$r,
  level=0.95)
@
The construction of the confidence interval is best shown by a plot of the smoothed profile likelihood (Fig.~\ref{fig:mcap-plot}).
In this toy example, the exact likelihood can be calculated using the Kalman filter, and this is carried out by the \code{panelGompertzLikelihood} function.
The likelihood can then be maximized using a general-purpose optimization procedure such as \code{optim()} in R.
With large numbers of parameters, and no guarantee of convexity, this numerical optimization is not entirely routine.
One might consider a block optimization strategy, but here we carry out a simple global search, which took \Sexpr{myRound(exact_profile_time["elapsed"]/60,1)} minutes to compute the profile likelihood, once parallelized.
The deterministic search is also not entirely smooth, and so we apply MCAP as for the Monte Carlo search.
Both deterministic and Monte Carlo optimizations can benefit from a block optimization strategy which alternates between shared and unit-specific parameters \citep{breto19}.
Such algorithms can be built using the \panelPomp functions we have demonstrated, and they will be incorporated into the package once they have been more extensively researched.

<<mcap-plot,echo=F,fig.width=6,fig.height=4,out.width="5in",fig.cap="The Monte Carlo adjusted profile confidence interval (solid red lines, evaluation points shown as circles). Construction using deterministic optimization of the likelihood calculated by the Kalman filter (dashed lines, evaluation points show as squares).">>=

  par(mai=c(0.7,0.7,0.3,0.3))
  mc <- gomp_mcap
  ylim=range(c(mc$fit$smoothed,mc$logLik,exact_profile_table[,"logLik"]))
  plot(mc$logLik ~ mc$parameter, xlab="",ylab="",ylim=ylim, col="red")
  mtext(side=2,text="profile log likelihood",line=2.5)
  mtext(side=1,text="r",line=2.5)
  lines(mc$fit$parameter,mc$fit$smoothed, col = "red", lwd = 1.5)
  abline(v=mc$ci,col="red")
  abline(h=max(mc$fit$smoothed,na.rm=T)-mc$delta,col="red")

#  lines(exact_profile_table[,"r"],exact_profile_table[,"logLik"],lty="dashed")
  optim_mcap <- pomp::mcap(logLik=exact_profile_table[,"logLik"],
  parameter=exact_profile_table[,"r"],
  level=0.95)
  mc2 <- optim_mcap
  points(mc2$parameter,mc2$logLik,pch=0)
  lines(mc2$fit$parameter,mc2$fit$smoothed, col = "black", lty="dashed")
  abline(v=mc2$ci,col="black",lty="dashed")
  abline(h=max(mc2$fit$smoothed,na.rm=T)-mc2$delta,col="black",lty="dashed")

@

\section{Conclusion}

The analysis demonstrated in Section~\ref{sec:meth} gives one approach to plug-and-play inference for PanelPOMP models, but the scope of \panelPomp is far from limited to this approach.
\panelPomp is a general and extensible framework which encourages the development of additional functionality.
The \code{panelPomp} class and the corresponding workhorse functions provide an applications interface available to other future methodologies.
In this sense, \panelPomp provides an environment for sharing and developing PanelPOMP models and methods, both via future contributions to the \panelPomp package and via open source applications using \panelPomp.
This framework will facilitate comparison of new future methodology with existing methodology.

Likelihood evaluation and maximization was used to construct confidence intervals in Section~\ref{sec:meth}.
These calculations also provide a foundation for other techniques of likelihood-based inference, such as likelihood ratio hypothesis tests and model selection via Akaike's information criterion (AIC).
The examples discussed in Section~\ref{sec:examples} provide case studies in the use of these methods for scientific work.

Data analysis using large data sets or complex models may require considerable computing time.
Simulation-based methodology is necessarily computationally intensive, and access to a cluster computing environment extends the size of problems that can be tackled.
The workflow in Section~\ref{sec:meth} has a simple parallel structure that can readily take advantage of additional resources.
Embarrassingly parallel computations, such as computing the profile likelihood function at a grid of points, or replicated evaluations of the likelihood function, can be parallelized using the \pkg{foreach} package.

Panel data is widely available: for many experimental and observational systems it is more practical to collect short time series on many units than to obtain one long time series.
For time series data, fitting mechanistic models specified as partially observed Markov processes has found numerous applications for formulating and answering scientific hypotheses. \citep{breto09,king16}.
However, there are remarkably few examples in the literature fitting mechanistic nonlinear non-Gaussian partially observed stochastic dynamic models to panel data.
The \panelPomp package offers opportunities to remedy this situation.

The source code for \panelPomp is at \url{https://github.com/cbreto/panelPomp}.
Unit tests that cover 100\% of the code are provided at \url{https://github.com/cbreto/panelPomp/tests}, and these tests also provide useful examples of calls to the functions within \panelPomp.
The source code for this article is at \url{https://github.com/cbreto/panelPomp/vignettes/articles/package_tutorial}.

\section*{Acknowledgments}
The results in this paper were obtained using \R~\Sexpr{paste(R.Version()[6:7], collapse = ".")} with \pkg{panelPomp}~\Sexpr{packageVersion("panelPomp")} and pkg{pomp}~\Sexpr{packageVersion("pomp")}.
This work was supported by National Science Foundation grants DMS-1761603 and DMS-1646108, National Institutes of Health grants 1-U54-GM111274 and 1-U01-GM110712, and by MCIN/AEI/10.13039/501100011033 grants PID2020-116242RB-I00 and PID2023-152348NB-I00

\bibliographystyle{jasa3}

% References
\bibliography{bg}
\end{document}
